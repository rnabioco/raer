---
title: Introducing the raer package
author: 
  - name: Kent Riemondy
    affiliation: University of Colorado School of Medicine
  - name: Kristen Wells-Wrasman
    affiliation: University of Colorado School of Medicine
date: '`r Sys.Date()`'
output:
  BiocStyle::html_document
package: raer 
bibliography: ref.bib  
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}    
---

```{r, echo=FALSE, results="hide"}
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```

# Introduction

The `raer` (RNA Adenodine editing in R) package provides tools to characterize A-to-I editing in single cell and bulk RNA-sequencing datasets. Both novel and known editing sites can be quantified starting with BAM alignment files produced from multiple sequencing modalites. At it's core the raer package uses the pileup routines in the HTSlib C library to identify candidate sites, and leverages the annotation resources in the Bioconductor ecosystem to further characterize and identify high-confidence RNA editing sites.  

Here we will demonstate using the `raer` package to a) quantify known RNA editing in droplet scRNA-seq dataset,  b) identify editing sites with condition specific editing in bulk RNA-seq data, c) predict novel editing sites from bulk RNA-seq, and lastly extending the functionality in `raer` to characterize ...

## Analysing scRNA-seq data



# Characterizing RNA editing sites in single cell data

Here we will use the `raer` package to examine RNA editing in droplet-based single cell RNA-seq data. For this example analysis we will examine a single cell dataset containing human PBMC cells from [10x Genomics](https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-v3-1-chromium-x-with-intronic-reads-3-1-high). The single cell data was aligned and preprocessed using the 10x Genomics cellranger pipeline. The BAM file produced by cellranger contains a tag (`CB`) which indicates the cell-barcode associated with each alignment, as well as a tag containing the inferred UMI sequence (`UB`). 

We will quantify human editing 

A subset of a human PBMC scRNA-seq dataset from 10x Genomics, along with other
needed files can be downloaded and cached using `pbmc_10x()`. 

```{r message=FALSE}
library(raer)
library(scater)
library(SingleCellExperiment)
library(Rsamtools)
library(raerdata)
```

`pbmc_10x()` will return a list containing a `BamFile` object, a `GRanges` object with known RNA editing sites from the `RediPortal` database, and a `SingleCellExperiment` populated with the gene expression data and cell type annotations. 

```{r}
pbmc <- pbmc_10x()

pbmc_bam <- pbmc$bam
editing_sites <- pbmc$sites
names(editing_sites) <- NULL
sce <- pbmc$sce
```


```{r}
plotUMAP(sce, colour_by = "celltype")
```

Next we'll select editing sites to query. For this analysis we will use sites from the Rediportal database.

```{r}
editing_sites
```

The sites to quantified are specified using a custom formatted GRanges object with 1 base intervals, a strand (+ or -), and supplemented with metadata columns named `REF` and `ALT` containing the reference and alternate base to query. In this case we are
only interested in A->I editing, so we set the ref and alt to `A` and `G`. Note that the `REF` and `ALT` bases are in reference to strand. For a `-` strand interval the bases should be the complement of the `+` strand bases. Also note that these bases can be stored as traditional character vectors, or as `Rle()` objects to save memory.  

```{r}
editing_sites$REF <- Rle("A")
editing_sites$ALT <- Rle("G")
editing_sites
```

`pileup_cells()` quantifies edited and non-edited UMI counts per cell barcode, then collect the site counts into a SingleCellExperiment object. `pileup_cells()` accepts a `FilterParam()` class that specification how to perform read and site filtering. Note that `pileup_cells()` is strand sensitive by default, so it is important to ensure that the strand of the input sites is correctly annotated, and that the library type is correct for the type of data of interest. For 10x Genomics data, the library type is set to `fr-second-strand`, indicating that the strand of the alignments matches the strand of the RNA. See `XXXXXX` for handling unstranded data, such as the data produced by Smart-Seq libraries. 

Note that `bam_flags` argument is set to **include** duplicate reads by default. Droplet single cell libraries produce multiple cDNA fragments from a single reverse transcription event. The cDNAs are fragmented and therefore have different alignment positions despite being derived from a single original RNA molecule. If duplicates are removed, then only 1 representative fragment for a single UMI will be examined, which will exclude many valid regions. 

To exclude duplicate reads derived from PCR, `pileup_cells()` can use a UMI sequence, supplied via the `umi_tag` argument, to only count 1 read for each CB-UMI pair at each position. This strategy allows for reads from multiple fragments with the same UMI to be counted at multiple  sites enabling recovery of more sequence variants than counting only 1 read per UMI. 

Processing time can be reduced by operating in parallel across chromosomes, by supplying an appropriate `BiocParallel` backend to the `BPPARAM` argument (e.g. `MultiCoreParam()`).


```{r pileup_cells}
outdir <- file.path(tempdir(), "sc_edits")
cbs <- colnames(sce)

params <- FilterParam(min_mapq = 255L,
                      library_type = "fr-second-strand",
                      min_variant_reads = 1L)

e_sce <- pileup_cells(
    bamfile = pbmc_bam,
    sites = editing_sites,
    cell_barcodes = cbs,
    output_directory = outdir,
    cb_tag = "CB",
    umi_tag = "UB",
    param = params,
    verbose = FALSE
)
e_sce
```

The outputs from `pileup_cells()` are a `SingleCellExperiment` object populated with 
`nRef` and `nAlt` assays containing the base counts for the reference (unedited) and alternate (edited) alleles at each position. 

The sparseMatrices are also written to files, which can be load into R using the `read_sparray()` function.

```{r}
dir(outdir)
read_sparray(file.path(outdir, "counts.mtx.gz"),
             file.path(outdir, "sites.txt.gz"),
             file.path(outdir, "barcodes.txt.gz"))
```

Next we'll filter the single cell editing dataset to find sites with at least 5 cells with an editing event and add the editing counts to the gene expression SingleCellExperiment as an `altExp()`. 

```{r}
e_sce <- e_sce[rowSums(assays(e_sce)$nAlt > 0) >= 5, ]
e_sce <- calc_edit_frequency(e_sce, edit_from = "Ref", edit_to = "Alt", replace_na = FALSE)
altExp(sce) <- e_sce[, colnames(sce)]
```

With the editing sites added to the gene expression SingleCellExperiment we can use plotting and other methods previously developed for single cell analysis. Here we'll visualize editing sites with the highest edited read counts.

```{r}
to_plot <- rownames(altExp(sce))[order(rowSums(assay(altExp(sce), "nAlt")), decreasing = TRUE)]

lapply(to_plot[1:5], function(x) {
    plotUMAP(sce, colour_by = x, by_exprs_values = "nAlt")
})
```

Alternatively we can view these top edited sites as a Heatmap, showing the average
number of edited reads per site in each cell type. 

```{r}
altExp(sce)$celltype <- sce$celltype

plotGroupedHeatmap(altExp(sce),
    features = to_plot[1:25],
    group = "celltype",
    exprs_values = "nAlt"
)
```

`raer` provides additional tools to examine cell type specific editing. `find_celltype_de()` will perform statistical testing to identify sites with different editing frequencies between clusters/cell types. `calc_scAEI()` will calculate the Alu Editing Index (`AEI`) score in single cells. 

**If the editing sites of interest are not known, we recommend the following approach. First, treat the single cell data as a "bulk-RNA-seq" experiment, and use `pileup_sites()` and the `BULK RNA-SEQ workflow` to identify putative editing sites. Second, query these sites in single cell mode using `pileup_cells()`**

## Bulk RNA-Seq tutorial

Next we will demonstrate how to identify RNA editing sites with condition-specific editing frequencies. For this analysis a published bulk RNA-seq dataset will be analyzed, [GSE99249](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE99249), which consists of ADAR1 mutants and control human cell lines, conditionally treated with Interferon-Beta. We will examine data from two genotypes, ADAR1 WT and KO, both treated with IFN-B with triplicate samples. 

```{r}
library(raer)
library(SummarizedExperiment)
library(DESeq2)
library(ComplexHeatmap)
library(viridis)
library(rtracklayer)
```


Aligned BAM files and other necessary files have been preprocessed for this vignette and are available from the reardata package. These files can be downloaded and cached using the `GSE99249()` function, which will return a list containing the necessary data. 

```{r}
ifnb <- GSE99249()
names(ifnb)
```

`bams` contains a vector of `BamFile` objects with the paths to each BAM file. These BAM files are a subset of the full BAM files, containing alignments from chromosome 18.

```{r}
bam_files <- ifnb$bams
names(bam_files)
```

To quantify editing sites we will need a FASTA file to compare read alignments to the reference sequence. We'll use a FASTA file  containing chromosome 18 for this demo. 

```{r}
fafn <- ifnb$fasta
```

Lastly, we will use a database of known human editing sites from REDIPortal. These sites are collected in a GRanges object. 

```{r}
editing_sites <- ifnb$sites
editing_sites
```

## Generate editing site read counts 

The `pileup_sites()` function will process the BAM files and calculate base counts at each supplied position. The `FilterParam()` class provides numerous filters to exclude reads and bases based on commonly used filters for detecting RNA-editing events. Specific regions can be queried using the `region` argument which accepts a samtools style region specificaiton (e.g. `chr` or `chr:start-end`).

Internally, `pileup_sites()` will generate base count pileups in memory. However these pileups can also be stored in tabix-indexed files, for later retrieval, if needed.

```{r}
fp <- FilterParam(
    only_keep_variants = TRUE,
    trim_5p = 5,
    trim_3p = 5,
    min_base_quality = 30L,
    min_mapq = 255L,
    library_type = "fr-first-strand",
    min_splice_overhang = 10
)

rse <- pileup_sites(bam_files,
    fasta = fafn,
    sites = sites,
    region = "chr18",
    param = fp
)

rse
```


Pileups data is stored in a `RangedSummarizedExperiment` object, which facilitates comparisons across samples, and conveniently stores genomic coordinate information. The `rowData()` and `rowRanges()` slots are populated with the reference base (`REF`) and information related to each editing site, and similarly the `colData()` slot can be used to store sample metadata. 

The base counts and other information are stored in different assays within the object. `REF` and `ALT` bases and base count data are all provided in a stand specific fashion depending on the supplied `library-type` parameter. The `REF` and `ALT` bases are in reference to the strand. 

```{r}
assays(rse)
assay(rse, "nA")[1:5, ]
assay(rse, "nG")[1:5, ]
```

Next we will add sample information which will be useful for differential editing analysis. 

```{r}
colData(rse)$genotype_treatment <- factor(rep(
    c(
        "ADAR1KO Interferon beta",
        "Wildtype Interferon beta"
    ),
    each = 3
))

colData(rse)$genotype <- factor(rep(
    c(
        "ADAR1KO",
        "Wildtype"
    ),
    each = 3
))
colData(rse)
```

## Prepare for differential editing 

We next use the `calc_edit_frequency` function to calculate the editing percentage and read depth at each position. With the `drop = TRUE` argument we will also exclude non-adenosine sites. The editing frequencies will not be used for differential editing analysis, which will be conducted using the raw counts, however these are useful for filtering and visualization. There are two additional assays with the editing frequency (`edit_freq`) and read `depth` computed based on the `edit_to` and `edit_from` counts. 


```{r}
rse <- calc_edit_frequency(rse,
    edit_from = "A",
    edit_to = "G",
    drop = TRUE
)
```

We will next subset the dataset to exclude low frequency editing events. For this analysis we will require that an editing site shows editing in at least 1 sample, and has at least 5 counts in each sample. 

```{r}
has_editing <- rowSums(assay(rse, "edit_freq") > 0) >= 1
has_depth <- rowSums(assay(rse, "depth") >= 5) == ncol(rse)

rse <- rse[has_editing & has_depth, ]
rse
```

Once the object has been filtered, we will transform it into an alternative data structure for DE analysis that contains an assay with read counts of both the `ALT` and `REF` alleles in a single matrix.

```{r}
deobj <- make_de_object(rse, min_prop = 0.05, min_samples = 3)

assay(deobj, "counts")[1:3, c(1,7,2,8)]
```

## Run differential editing

At this stage, you can use the object to perform DE yourself or use `find_de_sites()` to use `edgeR` or `DESeq2` to identify condition specific editing events. For differential editing, we use the design `design <- ~0 + condition:sample + condition:count` and perform testing to compare the edited read counts against unedited read counts. 

```{r}
deobj$sample <- factor(deobj$sample)
de_results <- find_de_sites(deobj, 
    test = "DESeq2",
    sample_col = "sample",
    condition_col = "genotype",
    condition_control = "Wildtype",
    condition_treatment = "ADAR1KO"
)
```

This returns a list containing the dds object, the full results, the significant results, and the model matrix. 

```{r}
de_results$sig_results[1:5, ]
```

```{r, fig.height=7, fig.width=5}
top_sites <- rownames(de_results$sig_results)[1:20]

Heatmap(assay(rse, "edit_freq")[top_sites, ], 
        name = "editing frequency",
        col = viridis(100),
        column_labels = rse$genotype_treatment
)
```

As expected many of the identified sites are those with reduced editing in the ADAR1KO sample. 


## Examine overall editing activites using the Alu Editing Index

For some studies it may be informative to assess the overall ADAR editing activity rather
than examining individual editing sites. The **Alu Editing Index** (AEI), developed 
by @Roth2019-yu, is a metric that summarizes that amount of editing occurring 
at ALU elements which account for the vast majority of A-to-I editing (> 99%) in humans.

`raer` provides `calc_AEI()`, based on this approach, to calculate the AEI metric. Many of the same parameters used for `pileup_sites()` are available in `calc_AEI()`. 

First we will use the `AnnotationHub` pacakge to obtain coordinates for ALU elements in the human genome. For this example we will only examine a subset of ALUs on `chr18`. We will also use a `SNPlocs` package to identify SNPs overlapping the ALU elements from the dbSNP database, which will be excluded from the AEI calculation. The SNPlocs coordinates are `NCBI` based, whereas the `ALU` elements are based on `hg38`, we will therefore convert between the two as needed to obtain SNP and ALU element coordinates based on `hg38`. 


```{r}
library(AnnotationHub)
library(SNPlocs.Hsapiens.dbSNP144.GRCh38)

ah <- AnnotationHub()
rmsk_hg38 <- ah[["AH99003"]]

alus <- rmsk_hg38[rmsk_hg38$repFamily == "Alu", ]
alus <- alus[seqnames(alus) == "chr18", ]
alus <- keepStandardChromosomes(alus) 
alus <- alus[1:1000, ]

seqlevelsStyle(alus) <- "NCBI"
genome(alus) <- "GRCh38.p2"

alu_snps <- get_overlapping_snps(alus, SNPlocs.Hsapiens.dbSNP144.GRCh38)

seqlevelsStyle(alu_snps) <- "UCSC"
alu_snps[1:3, ]

seqlevelsStyle(alus) <- "UCSC"
alus[1:3, ]
```

`calc_AEI()` will return a matrix containing the AEI calculated for all allelic combinations and a more detailed table containing values for each chromosome.

```{r}
alu_index <- calc_AEI(bam_files, 
                      fasta = fafn, 
                      snp_db = alu_snps,
                      alu_ranges = alus, 
                      param = fp)
names(alu_index)
```

```{r}
Heatmap(alu_index$AEI, 
        name = "AEI",
        col = viridis(100), 
        row_labels = rse$genotype_treatment[match(rownames(alu_index$AEI),
                                                  rse$sample)]
)
```


The AEI in the `Wildtype` samples is highest for `A-to-G` as expected, and sharply 
reduced in the `ADAR1KO` samples. 

# Novel RNA editing site detection tutorial

Next we will demonstrate how to identify novel RNA editing sites using the `raer` package. In this analysis a published RNA-seq and Whole-Genome sequencing dataset will be analyzed. High coverage whole-genome sequencing was conducted [ERR262997](https://www.ebi.ac.uk/ena/browser/view/ERR262997?show=reads) along with paired-end RNA-seq [SRR1258218](https://www.ebi.ac.uk/ena/browser/view/SRR1258218?show=reads) in a human cell line (`NA12878`).

Aligned BAM files, a genome fasta file, and a GRanges object containing SNPs corresponding to the first 1Mb region of chr4 have been prepared for this vignette and can be downloaded and cached using `NA12878()`.

```{r, eval = FALSE}
wgsrna <- NA12877()
names(wgsrna)

```

```{r, eval = FALSE}
wgsrna$bams
```


Additionally we will use the following additional annotation resources:  
  
  - A database of known SNPs, for example the `SNPlocs.Hsapiens.dbSNP155.GRCh38` package. Due to space and memory constraints in this vignette we will use a BED file containing SNPs from the first 1Mb region of chr4.  
  - `TxDb.Hsapiens.UCSC.hg38.knownGene`, a database of transcript models. Alternatively these can be generated from a `.gtf` file using `makeTxDbFromGRanges()` from the `GenomicFeatures` package.  
  - RepeatMasker annotations, which can be obtained from the `AnnotationHub()` for hg38, as shown in the XXXX section. For space reasons these annotations for `chr4` have been included as a text file. 

```{r}
library(TxDb.Hsapiens.UCSC.hg38.knownGene)
chr4snps <- wgsrna$snps
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene

fns <- download_NA12878()
```

The `pileup_sites()` function can accept multiple bam files, here we supply one from RNA-seq, and one from whole genome sequencing. A subset of the filtering parameters (`FilterParam()`) can accept multiple arguments matched to the input bam files. This allows us to have distinct settings for the WGS and RNA-seq BAM files.

```{r}
wgs_bam <- fns$bams[1]
rna_bam <- fns$bams[2]
bams <- c(rna_bam, wgs_bam)
names(bams) <- c("rna", "dna")
fp <- FilterParam(
    min_depth = 1,               # minimum read depth across all samples
    min_base_quality = 30,       # minimum base quality
    min_mapq = c(255, 30),       # minimum MAPQ for each bam file
    library_type = c("fr-first-strand", "genomic-unstranded"), # library-type for each bam file
    trim_5p = 5,                 # bases to trim from 5' end of alignment
    trim_3p = 5,                 # bases to trim from 3' end of alignment
    indel_dist = 4,              # ignore read if contains an indel within distance from site
    min_splice_overhang = 0,    # required alignment overhang in order to count read with splice 
    max_mismatch_type = c(3, 3), # exclude read if contains 3 types of variants and 3 mismatches
    read_bqual = c(0.25, 20),    # minimum fraction of the read (0.25) that must have base quality of (20)
    only_keep_variants = c(TRUE, FALSE), # report site if rnaseq bam has variant
    report_multiallelic = FALSE, # do not report sites with multiple variant alleles
)

rse <- pileup_sites(bams,
                    fasta = wgsrna$fasta,
                    chrom = "chr4",
                    param = fp
)

rse
```


Next we filter to keep those sites with a variant in the RNA-seq, but no variant
in the DNA-seq, and a minimum of 5 reads covering the site in the DNA-seq. The DNA-seq 
data, is unstranded, and therefore will be reported on the "+" strand whereas the 
RNA-seq data will be reported on expressing RNA strand. 
We therefore use `subsetByOverlaps(..., ignore.strand = TRUE)` to retain sites
passing these DNA-seq based filters independent of strand. 

```{r}
to_keep <- (assay(rse, "nRef")[, "dna"] >= 5 & assay(rse, "ALT")[, "dna"] == "-")
rse <- subsetByOverlaps(rse, rse[to_keep, ], ignore.strand = TRUE)
nrow(rse)
```

Next we filter to remove any multiallelic sites. These sites are stored as comma-separated
strings in the `ALT` assay (e.g. `G,C`). Non-variant sites are stored as `-`. 
`filter_multiallelic()` will remove any sites that have multiple variants in the samples present in the `summarizedExperiment` object. It will add a new column to the `rowData()` to indicate the variant for each site, and will calculate an `allele_freq` assay with variant allele frequencies for each sample. 

```{r}
rse <- filter_multiallelic(rse)
rse <- calc_edit_frequency(rse)
rowData(rse)
```


Next we'll remove sites in simple repeat regions. We will add repeat information to the `rowData()` using the `annot_from_gr()` function.

```{r}
rse <- annot_from_gr(rse, rmsk_hg38, cols_to_map = c(c("repName", "repClass", "repFamily")))

rowData(rse)[c("repName", "repFamily")]
```


```{r}
rse <- rse[!rowData(rse)$repFamily %in% c("Simple_repeat", "Low Complexity")]
```

Next we'll remove sites adjacent to other sites with different variant types. For example if an A->G variant is located proximal to a C->T variant then the variants will be removed.  

```{r}
rse <- filter_clustered_variants(rse, txdb, variant_dist = 100)
rse
```

Next, we'll annotate if the site is a known SNP and remove any known SNPs. If using a SNPlocs package you can use the `annot_snp()` function. However we will use the `annot_from_gr()` function to annotate using the prebuilt `chr4snps` object.

```{r}
rse <- annot_from_gr(rse, chr4snps, "name")
rowData(rse)[c("name")]

rse <- rse[is.na(rowData(rse)$name), ]
rse
```
Lastly, we'll further filter the edit sites to require that the editing frequency is > 0.05 and that at least 2 reads support the editing site. 

```{r}
to_keep <- assay(rse, "edit_freq")[, 1] > 0.05
rse <- rse[to_keep, ]

rse <- rse[assay(rse, "nAlt")[, 1] >= 2]
```


```{r}
stopifnot(all(rowData(rse)$REF == "A" & rowData(rse)$ALT == "G"))
rowRanges(rse)
```

## Other use cases

...

<details style="margin-bottom:10px;">
<summary>
    Session info
</summary>

```{r}
sessionInfo()
```

</details>


