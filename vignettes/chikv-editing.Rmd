---
title: "RNA editing during viral infection"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{chikv-editing}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Overview

This is an analysis of RNA editing during a Chikungunya (CHIKV) infection of
mouse lymph node tissue, described in:

Carpentier KS, Sheridan RM, Lucas CJ, Davenport BJ, Li FS, Lucas ED, McCarthy
MK, Reynoso GV, May NA, Tamburini BAJ, Hesselberth JR, Hickman HD, Morrison TE.
MARCO+ lymphatic endothelial cells sequester arthritogenic alphaviruses to limit
viremia and viral dissemination. EMBO J. 2021 Nov 15;40(22):e108966. doi:
10.15252/embj.2021108966. Epub 2021 Oct 7. [PMID: 34618370; PMCID:
PMC8591538](https://pubmed.ncbi.nlm.nih.gov/34618370/).

In this study, mice were infected with an attenuated strain of CHIKV and lymph
nodes were harvested after 24 hours and analyzed by 10x Genomics 3' single-cell
RNA sequencing, focusing on CD45- stromal cells.

Data from triplicate infection and mock samples were analyzed by the CellRanger
pipeline, and output BAM files serve as the input data below.

### Sample information

* Todo: Create table of samples, 10x summary

```{r libs, message=FALSE}
library(raer)
library(tidyverse)
library(ggtext)
library(cowplot)
library(fs)
library(glue)
library(qs)
library(janitor)

library(BiocParallel)
library(SummarizedExperiment)
library(plyranges)
library(VariantAnnotation)
library(TxDb.Mmusculus.UCSC.mm10.knownGene)
```

```{r setup_common_data}
ext_path <- fs::path('~/projects/raer-chikv')
samples <- c('A1','A2','A3', 'M1', 'M2', 'M3')

fns = list(
  bams    = fs::path(ext_path, 'bam', str_c( samples, '.bam')),
  bais    = fs::path(ext_path, 'bam', str_c(samples, '.bam.bai')),
  fasta   = fs::path(ext_path, 'ref', 'mm10_CHIKV_AF15561.fa.gz'),
  rmsk_db = fs::path(ext_path, 'ref', 'rmsk.mm10.tsv.gz'),
  snp_db  = fs::path(ext_path, 'ref', 'snp142.mm10.bed.gz'),
  redi_db = fs::path(ext_path, "ref", 'rediportal.mm10.cleaned.tsv.gz')
)
```

### External data sources

* `mm10_CHIKV_AF15561.fa.gz` is a combined FASTA of mouse mm10 (XXX: source?) and the
  CHIKV genome. It's the reference that was used during the upstream CellRanger step.

* `rmsk.mm10.tsv.gz` is the RepeatMasker table downloaded from UCSC.

* `snp142.mm10.bed.gz` is a SNP table downloaded from UCSC.

* `rediportal.small.mm10.tsv.gz` are sites from the [REDIportal database](http://srv00.recas.ba.infn.it/atlas/index.html). The full
  table is poorly formatted, having 25 column headers and 22 data columns, so
  these data are the first 22 columns, and anything after the first ~10 may
  not be useful.
  
## Pileup

This is the main raer pileup routine. On this data set, this step takes about 4
hours (parallelized) and generates a large `RangedSummarizedExperiment` (`rse`)
with \~48 million sites.

```{r run_pileup, eval=FALSE}
fp <- FilterParam(
  # min depth of 3 for each replicate
  min_nucleotide_depth = 3,
  min_base_quality     = 30,
  min_mapq             = rep(255, 6),
  library_type         = rep("fr-second-strand", 6),
  trim_5p              = 5,
  trim_3p              = 5,
  indel_dist           = 4,
  homopolymer_len      = 6,
  max_mismatch_type    = c(3, 3),
  min_read_bqual       = c(0.25, 20),
  only_keep_variants   = rep(TRUE, 6)
)

bpp <- SnowParam(workers = 24)
plps <- get_pileup(
  fns$bams,
  fafile = fns$fasta,
  filterParam = fp,
  BPPARAM = bpp
)

names(plps) <- samples 
plps

all_rse <- create_se(plps)

# remove multi-allelics now, they're not much use later.
# this step removes about 15% (~8 million) of the sites.
all_rse <- remove_multiallelic(all_rse)

chikv_rse <- subsetByOverlaps(
  all_rse,
  filter(rowRanges(all_rse), seqnames == 'CHIKV_AF15561')
)

mm_rse <- subsetByOverlaps(
  all_rse,
  filter(rowRanges(all_rse), seqnames != 'CHIKV_AF15561')
)

qs::qsave(all_rse, fs::path(ext_path, '/rds/all_rse.rds'), nthreads = 10)
qs::qsave(mm_rse, fs::path(ext_path, '/rds/mm_rse.rds'), nthreads = 10)
qs::qsave(chikv_rse, fs::path(ext_path, '/rds/chikv_rse.rds'), nthreads = 10)
```

```{r load_rds, eval = FALSE}
all_rse <- qs::qread(fs::path(ext_path, '/rds/all_rse.rds'), nthreads = 10)
mm_rse <- qs::qread(fs::path(ext_path, '/rds/mm_rse.rds'), nthreads = 10)
chikv_rse <- qs::qread(fs::path(ext_path, '/rds/chikv_rse.rds'), nthreads = 10)
```

## Filtering for high confidence sites

From the intial set of \~50 million sites from the pileup, we filter
based on several criteria:

1.  filter on `nVar`, requiring at least 3 reads for every sample among
    replicates

2.  remove clustered variants and variants near splice sites, as these
    tend to be lower confidence due to mapping artifacts

3.  after `calc_edit_frequency()`, filter on `depth` and `edit_freq`,
    requiring a minimum of 3 reads and an editing frequency of at least
    5%.

4.  annotate the remaining variants based on overlap with reference
    databases of repeats and SNPs, and remove variants based on ad hoc
    criteria

### Filtering sites by treshold

This is a helper function to filter samples within each replicate.

```{r filter_fxn}
filter_replicates <- function(rse, assay_name = NULL, thresh = NULL, n_rep = 3) {
 
  x <- assay(rse, assay_name)[, 1:6]
  
  mocks <- c('M1', 'M2', 'M3')
  virus <- c('A1', 'A2', 'A3')

  keep_mocks <- rowSums(x[, mocks] >= thresh) >= n_rep
  keep_virus <- rowSums(x[, virus] >= thresh) >= n_rep 

  # keep anything that passes the filter in either mock or virus samples
  keep_all <- keep_mocks | keep_virus
  
  rse[keep_all, ]
}
```

The order of filtering here is important: the first `nVar` filter
removes a large chunk of the data, so we only compute the next steps on
\~10% of the sites.

```{r filter_mm, eval = FALSE}
# filter for at least 3 reads at each site every sample in the replicates.
# this removes a large chunk of the data that is low coverage, ~90% or so
# n = 861939 after this step
mm_rse_filt <- filter_replicates(mm_rse, "nVar", thresh = 3)

# Next, remove sites based on gene annotations
txdb <- TxDb.Mmusculus.UCSC.mm10.knownGene

# n = 325352 after this step
mm_rse_filt <- remove_clustered_variants(
  mm_rse_filt, txdb, variant_dist = 100
  ) |>
  remove_splice_variants(txdb)

# calculate `edit_freq` and `depth`
mm_rse_filt <- calc_edit_frequency(mm_rse_filt)

# filter on site depth >= 3 for all samples within replicates (nVar + nRef)
# n = XXX 
mm_rse_filt <- filter_replicates(mm_rse_filt, "depth", thresh = 6)

# filter for edit_freq >= 0.05 for at least 3 samples
# n = 266645
mm_rse_filt <- filter_replicates(mm_rse_filt, "edit_freq", thresh = 0.05)

mm_rse_filt
```

Now do the same for viral data --- these may be a bit harsh for the
virus coverage we have.

```{r filter_chikv, eval = FALSE}
# n = 4.25
chikv_rse_filt <- filter_replicates(chikv_rse, "nVar", thresh = 3)

# calculate edit frequencies and depth
chikv_rse_filt <- calc_edit_frequency(chikv_rse_filt)

# filter on site depth >= 3 for all samples within replicates 
chikv_rse_filt <- filter_replicates(chikv_rse_filt, "depth", thresh = 3)

# filter for edit_freq >= 0.05 for all replicates
# n = 42
chikv_rse_filt <- filter_replicates(chikv_rse_filt, "edit_freq", thresh = 0.05)

chikv_rse_filt
```

### Filtering by annotation

Filter the mouse data by annotation, comparing to reference SNP and
repeat databases.

```{r annotate_rse, eval = FALSE}
# load external annotations

rmsk_db <-  read_tsv(
  fns$rmsk_db,
  col_names = c('seqnames', 'start', 'end', 'strand', 'repName', 'repClass', 'repFamily')
) |>
  plyranges::as_granges()

# XXX: it might be useful to get a version of this table that has `ref` and `alt` alleles
# so we can quickly compute variant stats
snp_db  <- read_tsv(
  fns$snp_db,
  col_names = c('seqnames', 'start', 'end', 'snpId', 'score', 'strand')
) |>
  plyranges::as_granges()

# annotate the filtered sites
mm_rse_filt <- annot_from_gr(
  mm_rse_filt,
  rmsk_db,
  cols_to_map = c("repName", "repFamily")
)

mm_rse_filt <- annot_from_gr(
  mm_rse_filt,
  snp_db,
  cols_to_map = "snpId"
)

# filter out specific repeat classes
# n = 233792
mm_rse_filt <- mm_rse_filt[
  !rowData(mm_rse_filt)$repFamily %in%
    c("Simple_repeat", "Low_complexity", "Low_complexity,Low_complexity")
]

# filter out common variants (i.e., already have a snpId)
# n = 217893
mm_rse_filt <- mm_rse_filt[is.na(rowData(mm_rse_filt)$snpId)] 

mm_rse_filt
```

## Save filtered data

```{r save_filt_data, eval=FALSE}
qs::qsave(mm_rse_filt, fs::path(ext_path, '/rds/mm_rse_filt.rds'), nthreads = 10)
qs::qsave(chikv_rse_filt, fs::path(ext_path, '/rds/chikv_rse_filt.rds'), nthreads = 10)
```

## Exploratory analysis

### Data tidying

```{r tidy_data, eval=FALSE}
prep_tibble <- function(rse, assay_name) {
  assay(rse, assay_name) |>
    as.data.frame() |>
    rownames_to_column("site") |>
    as_tibble()
}

tidy_nref <- prep_tibble(mm_rse_filt, "nRef") |>
  pivot_longer(-site) |> dplyr::rename(n_ref = value)
tidy_nvar <- prep_tibble(mm_rse_filt, "nVar") |>
  pivot_longer(-site) |> dplyr::rename(n_var = value)
tidy_var <- prep_tibble(mm_rse_filt, "Var") |>
  pivot_longer(-site) |> dplyr::rename(var = value)
tidy_depth <- prep_tibble(mm_rse_filt, "depth") |>
  pivot_longer(-site) |> dplyr::rename(depth = value)
tidy_edit_freq <- prep_tibble(mm_rse_filt, "edit_freq") |>
  pivot_longer(-site) |> dplyr::rename(edit_freq = value)

tidy_annots <- rowData(mm_rse_filt) |>
  as.data.frame() |>
  rownames_to_column("site") |>
  as_tibble() |>
  dplyr::select(-Ref, -Var, -snpId)
  
# combine the above
tidy_all <- left_join(tidy_var, tidy_nvar, by = c('site', 'name')) |>
  left_join(tidy_nref, by = c('site', 'name')) |>
  left_join(tidy_depth, by = c('site', 'name')) |>
  left_join(tidy_edit_freq, by = c('site', 'name')) |>
  left_join(tidy_annots, by = c('site'))
 
tidy_all <- tidy_all |> 
  # filter out ambiguous var
  filter(var != '-' & !str_detect(var, '^N')) |>
  # polish columns in variables
  separate(name, into = c('treat', 'rep'), sep = 1) |>
  # use intuitive var, i.e. `AT` -> `A>T`
  separate(var, into = c('ref', 'alt'), sep = 1) |>
  unite(var, ref:alt, sep = '>') |>
  # use intuitive treatment names
  mutate(
    treat = case_when(
      treat == 'A' ~ 'virus',
      treat == 'M' ~ 'mock'
    )
  ) |>
  separate(site, into = c('chrom', 'pos', 'strand'), sep = '_') |>
  arrange(var) |>
  mutate(across(c(treat, rep, var), as_factor)) |>
  janitor::clean_names()

qs::qsave(tidy_all, file = fs::path(ext_path, '/rds/tidy_all.rds'), nthreads = 8)    
```

### **YO Start here!!!!**

```{r load_rds}
mm_rse_filt <- qs::qread(fs::path(ext_path, '/rds/mm_rse_filt.rds'), nthreads = 10)
chikv_rse_filt <- qs::qread(fs::path(ext_path, '/rds/chikv_rse_filt.rds'), nthreads = 10)
tidy_all <- qs::qread(fs::path(ext_path, '/rds/tidy_all.rds'), nthreads = 10)    
```

### Variants identified by the pileup

```{r plot_counts}
var_counts <-
  tidy_all |>
  group_by(treat, rep) |>
  dplyr::count(var) |>
  arrange(var) |>
  mutate(
    treat = fct_relevel(treat, c('mock', 'virus'))
  )

ggplot(
  # add a name column that highlights `A>G` in bold, red text
  mutate(
    var_counts,
    plt_name = case_when(
      var == 'A>G' ~ "<b style='color:red'>A>G</b>",
      .default = var
    ),
    plt_name = fct_relevel(
      as_factor(plt_name),
      "<b style='color:red'>A>G</b>",
      after = 1
    )
  ),
  aes(x = plt_name, y = n / 1e5, fill = rep)
  ) +
  geom_col() +
  facet_grid(~ treat) +
  scale_fill_brewer(palette = 'Greys') +
  labs(
    x = '',
    y = 'n (x 1e5)'
  ) + 
  theme_cowplot() +
  theme(
    axis.text.x = element_markdown(angle = 45, hjust = 1)
  )
```

The plot of counts above shows us a few things:

*   The most abundant variants are anything to A (`C>A`, `G>A`, `T>A`).
    I'm honestly not sure where that signal comes from, and Kent is
    stumped too.

    I considered calculating a normalized frequency comparing to the raw data,
    but (a) that's an expensive calculation and (b) most of those raw sites are
    low coverage anyway (see the `nVar` step at the beginning), so are going to
    be largely uninformative.

    I think the thing to do is to figure out how the remaining filters
    behave for that subset of sites. It's possible these `X>A` sites are
    generally lower coverage relative to the signal (`A>G`), and so
    improved thresholds for the filtering steps may eliminate them.

*   The next most abundant variant is the signal of adenosine editing
    and the one we're after (`A>G`). so all good there. There are about
    1e4 `A>G` sites per replicate:

    ```{r}
    filter(var_counts, var == 'A>G') 
    ```
    
*   There's a small signal for `T>C` (not sure what that is), and the
    remaining variants are at much lower levels.

### Editing frequency and depth

```{r plot_depth_edit_freq}
plot_tbl <-
  tidy_all |>
    mutate(log_depth = log10(depth)) |>
    dplyr::select(-(chrom:strand), -depth, -starts_with('rep_')) |>
    pivot_longer(edit_freq:log_depth) |>
    arrange(var)
  
ggplot(
  # add a name column that highlights `A>G` in bold, red text
  mutate(
    plot_tbl,
    plt_name = case_when(
      var == 'A>G' ~ "<b style='color:red'>A>G</b>",
      .default = var
    ),
    plt_name = fct_relevel(
      as_factor(plt_name),
      "<b style='color:red'>A>G</b>",
      after = 1
    )
  ),
  aes(x = plt_name, value, fill = rep)
  ) +
  geom_boxplot(outlier.shape = NA) +
  facet_grid(name ~ treat, scales = 'free_y') +
  theme_cowplot() +
  scale_fill_brewer(palette = 'Greys') +
  theme(
    axis.text.x = element_markdown(angle = 45, hjust = 1)
  ) + 
  labs(
    x = ''
  )
  
```

OK, now it seems like we're getting somewhere. The plot above shows that:

- `A>G` has the *lowest* editing frequency. I'm not entirely sure how to think
  about this; I think we expect true editing events to be well under 100%
  modified; the remaining sites with higher editing frequencies could just be
  somewhat common variants that aren't filtered? At a minimum this gives us a
  useful ad hoc filter.
  
- `A>G` has the *highest* log_depth, by ~0.5 log, which is great,
  and I think a good indication that we're enriching for interesting sites.

### Variants among repeat classes

```{r rep_families}
rep_counts <- tidy_all |>
  dplyr::select(treat, var, rep_name, rep_family) |>
  filter(!is.na(rep_name)) |>
  pivot_longer(-c(treat, var), names_to = 'rep_class', values_to = 'rep_name') |>
  group_by(treat, var, rep_class) |>
  dplyr::count(rep_name)

filter(
  rep_counts,
  rep_class == 'rep_family' & n >= 20,
  # examine the most abundant / interesting variants
  var %in% c('A>G', 'G>A', 'C>A', 'T>A')
) |>
  ggplot(aes(fct_reorder(rep_name, n), log10(n), fill = treat)) +
    geom_col() +
    coord_flip() +
    facet_grid(~ var) +
    theme_cowplot() + 
    scale_fill_manual(values = c('black', 'red')) +
  theme(axis.text.y = element_text(size = 8)) +
  labs(
    x = '',
    y = 'n variants in repeats (log10)'
  )
```

Doesn't appear to be a strong enrichment for a variant type among repeat classes.

### Variants in genic regions

```{r annotate_variants, eval=FALSE}
# this won't run until set get the seqlevels to match
intersect(seqlevels(txdb), seqlevels(rowRanges(mm_rse_filt)))
setdiff(seqlevels(txdb), seqlevels(rowRanges(mm_rse_filt)))
          
VariantAnnotation::locateVariants(rowRanges(mm_rse_filt), txdb, AllVariants())
```
### Cross-referencing with REDIportal

```{r rediportal_xref, message=FALSE}
redi_db <- read_tsv(
  fns$redi_db,
  col_names = TRUE
) |>
  janitor::clean_names()

redi_db <- 
  setNames(
    redi_db,
    names(redi_db) |>
      str_replace('_wg_encode_gencode_basic_vm16', '_gencode') |>
      str_replace('_ref_gene', '_refgene') |>
      str_replace('repeat', 'repeat_class')
  ) |>
  dplyr::rename(
    seqnames = region,
    start = position
  ) |>
  mutate(
    end = start + 1
  ) |>
  relocate(end, .after = 2) |>
  relocate(strand, .after = 3) |>
  # we'll only keep gencode annotations, through `exonic_func`
  dplyr::select(seqnames:exonic_func_gencode) |>
  rename_with(~ str_c('redi_', .x), .cols = ref:exonic_func_gencode) |>
  plyranges::as_granges()

mm_rse_filt_redi <- annot_from_gr(
  mm_rse_filt,
  redi_db,
  cols_to_map = c(
    'redi_ref',
    'redi_ed',
    'redi_func_gencode',
    'redi_gene_gencode'
  )
)

# tidy code for analysis
tidy_redi_tbl <- 
  rowData(mm_rse_filt_redi) |>
    as.data.frame() |>
    rownames_to_column('site') |>
    as_tibble() |>
    janitor::clean_names() |>
    pivot_longer(-c(site, ref, var)) |>
    filter(!is.na(value)) |> 
    separate(site, into = c('chrom', 'pos', 'strand'), sep = '_') |>
    dplyr::select(-ref, -strand) |>
    separate(var, into = c('ref','ed'), sep = 1) |>
    unite(var, ref:ed, sep = '>') |>
    pivot_wider() |>
    filter(!is.na(redi_ref)) |>
    dplyr::select(-redi_ref, -redi_ed) |>
    rowwise() |>
    mutate(
      redi_func_gencode = str_split_1(redi_func_gencode, ',')[[1]],
      redi_gene_gencode = str_split_1(redi_gene_gencode, ',')[[1]]
    ) |>
    ungroup() |>
    mutate(
      rep_family_collapse = case_when(
        rep_family == 'Alu' ~ 'Alu',
        rep_family == 'L1' ~ 'L1',
        rep_family == 'B2' ~ 'B2',
        rep_family == 'B4' ~ 'B4',
        str_detect(rep_family, '^ERV') ~ 'ERV family',
        is.na(rep_family) ~ 'Not in repeat',
        .default = 'Other repeat'
      )
    )
```

```{r redi_plots}
total_sites <- nrow(tidy_redi_tbl)
n_rep_family <- length(unique(tidy_redi_tbl$rep_family_collapse))

# functional annotations
func_counts <- tidy_redi_tbl |>
  dplyr::count(redi_func_gencode) |>
  dplyr::rename(func_n = n)

tidy_redi_tbl |>
  dplyr::count(
    redi_func_gencode,
    rep_family_collapse,
    sort = TRUE) |>
  left_join(func_counts) |>
  ggplot(
    aes(
      x = fct_reorder(redi_func_gencode, -func_n),
      y = n,
      fill = fct_relevel(rep_family_collapse, 'Not in repeat', after = Inf)
    )
  ) +
  geom_col() +
  theme_cowplot() +
  labs(
    x = '',
    y = 'count',
    title = 'REDIportal annotation of mouse A>G sites',
    subtitle = glue('n = {scales::comma(total_sites)} total sites'),
    fill = 'Repeat class'
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1)
  ) +
  scale_fill_manual(
    values = c(
      scales::brewer_pal(palette = "Dark2")(n_rep_family - 1),
      'grey40'
    )
  )
```

## TODO

- [ ] Count number of A>G in our data vs rediportal (common and unique to either)

- [ ] Examine edit_freq within REDIportal xref data.

- [ ] Examine how mouse edits track with mock or virus. 

- [ ] Remove contigs and `_random` chromosomes from all objects early on,
  and relevel the GRanges objects.
  
  This will likely eliminate warnings from `annot_from_gr()` like `Each of the 2
  combined objects has sequence levels not in the other`, and may also enable
  `VariantAnnotation::locateVariants()` to work correctly.

