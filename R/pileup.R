#' Generate base counts using pileup
#'
#' @details Multiple bam files can be processed together, with files being
#' written for each bam file. In this mode the output regions will be consistent across all files.
#' The min_mapq, only_keep_variants, and library_type parameters can be specified for each input files.
#'
#' @param bamfiles paths to 1 or more bam files
#' @param fafile path to fasta file
#' @param bedfile path to bed file with sites or regions to query
#' @param region samtools region query string (i.e. chr1:100-1000)
#' @param chroms chromosomes to process, not to be used with region
#' @param filterParam object of class [FilterParam()] which specify various
#' filters to apply to reads and sites during pileup.
#' @param bedidx A BedFile object, if supplied, pileup will use index
#' generated by [indexBed()]
#' @param bam_flags bam flags to filter or keep, use [Rsamtools::scanBamFlag()]
#'  to generate
#' @param reads if supplied a fasta file will be written with reads that pass filters
#'  and contain variants
#' @param bad_reads a textfile containing read names to exclude from pileup. Readnames
#' should be formated as readid_1 or readid_2 or readid for paired end first read
#' paired-end second read or single end data.
#' @param return_data if `TRUE`, data is returned as a GRanges, if `FALSE` a character vector
#' of tabix-index files, specified by `outfile_prefix`, will be returned.
#' @param outfile_prefix Output prefix for tabix indexed files. If `NULL`, no files will be
#' produced.
#' @param use_index if TRUE regions supplied in the `bedfile` will be queried using the
#' bam file index. By default (FALSE) all alignments are queried via streaming and regions
#' in the bedfile are used to select the sites to keep. Using the index can be much faster
#' when querying a small number of sites in large bamfiles. With many sites in the bedfile
#' , or with small bamfiles, this option may be slower than streaming.
#' @param BPPARAM A [BiocParallel] class to control parallel execution. Parallel
#' processing occurs per chromosome, so is disabled when run on a single region.
#' @param verbose if TRUE, then report progress.
#'
#' @returns A list containing a `GRanges` object for each input bam file, or a vector
#' of the output tabixed file names if `return_data` is FALSE.
#'
#' @examples
#' bamfn <- system.file("extdata", "SRR5564269_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' bam2fn <- system.file("extdata", "SRR5564277_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' fafn <- system.file("extdata", "human.fasta", package = "raer")
#'
#' plp <- get_pileup(bamfn, fafn)
#' plps <- get_pileup(c(bamfn, bam2fn), fafn)
#' fp <- FilterParam(only_keep_variants = TRUE,  min_nucleotide_depth = 55)
#' get_pileup(bamfn, fafn, filterParam = fp)
#'
#' @importFrom Rsamtools bgzip indexTabix TabixFile scanTabix
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom GenomeInfoDb seqlevels seqinfo seqlengths
#' @importFrom BiocParallel SerialParam bpstop bplapply ipcid ipclock ipcunlock
#' @rdname get_pileup
#' @export
get_pileup <- function(bamfiles,
                       fafile,
                       bedfile = NULL,
                       region = NULL,
                       chroms = NULL,
                       filterParam = FilterParam(),
                       outfile_prefix = NULL,
                       bedidx = NULL,
                       bam_flags = NULL,
                       reads = NULL,
                       return_data = TRUE,
                       BPPARAM = SerialParam(),
                       use_index = FALSE,
                       bad_reads = NULL,
                       verbose = FALSE) {

  bamfiles <- path.expand(bamfiles)
  fafile <- path.expand(fafile)
  n_files <- length(bamfiles)

  if (!is.null(bedfile)) {
    bedfile <- path.expand(bedfile)
    if (!file.exists(bedfile)) {
      stop("bedfile not found: ", bedfile, call. = FALSE)
    }
  }

  if (!all(file.exists(bamfiles))) {
    stop("bamfile(s) not found: ", bamfiles[!file.exists(bamfiles)], call. = FALSE)
  }

  if (!file.exists(fafile)) {
    stop("fasta file not found: ", fafile, call. = FALSE)
  }

  if (is.null(outfile_prefix)) {
    if (!return_data) {
      stop("an outfile_prefix must be supplied if data is written to files")
    }
    in_memory <- TRUE
    outfiles <- "."
  } else {
    in_memory <- FALSE
    outfiles <- paste0(outfile_prefix, "_", seq_len(n_files), ".plp")
    if (!dir.exists(dirname(outfile_prefix))) {
      dir.create(dirname(outfile_prefix), recursive = TRUE)
    }
    outfiles <- path.expand(outfiles)
    if (length(outfiles) != n_files) {
      stop("# of outfiles does not match # of bam input files: ", outfiles)
    }
    # remove files if exist, to avoid appending to existing files
    unlink(outfiles)
  }

  contigs <- GenomeInfoDb::seqinfo(Rsamtools::BamFile(bamfiles[1]))
  contig_info <- GenomeInfoDb::seqlengths(contigs)
  chroms_to_process <- names(contig_info)
  if (is.null(region)) {
    if (!is.null(chroms)) {
      if (length(chroms) == 1) {
        region <- chroms
        chroms_to_process <- chroms
      } else {
        # not sure how to catch NULL in rcpp so using "." to indicate no region instead
        region <- "."
        chroms_to_process <- chroms
      }
    } else {
      region <- "."
    }
  } else {
    chroms_to_process <- get_region(region)$chrom
  }

  missing_chroms <- chroms_to_process[!chroms_to_process %in% names(contig_info)]

  if (length(missing_chroms) > 0) {
    warning("the following chromosomes are not present in the bamfile(s):\n",
      paste(missing_chroms, collapse = "\n"),
      call. = FALSE)
    chroms_to_process <- setdiff(chroms_to_process, missing_chroms)
  }

  chroms_to_process <-
    chroms_to_process[order(match(chroms_to_process, names(contig_info)))]

  if (length(chroms_to_process) == 0) {
    stop("No chromosomes requested are found in bam file",
      call. = FALSE)
  }

  idx_ptr <- NULL
  if (!is.null(bedidx)) {
    if (!is(bedidx, "BedFile") & !(bedidx$open)) {
      warning("bedidx not valid, setting to NULL")
      idx_ptr <- NULL
    }

    if (is_null_extptr(bedidx$.extptr)) {
      warning("bedidx pointer not valid, setting to NULL")
      idx_ptr <- NULL
    } else {
      idx_ptr <- bedidx$.extptr
    }
    bedfile <- "."
  }

  if (is.null(bam_flags)) {
    bam_flags <- Rsamtools::scanBamFlag(isSecondaryAlignment = FALSE,
      isNotPassingQualityCont = FALSE,
      isDuplicate = FALSE,
      isSupplementaryAlignment = FALSE)
  } else {
    if (length(bam_flags) != 2 || !all(names(bam_flags) == c("keep0", "keep1"))) {
      stop("bam_flags must be generated using Rsamtools::scanBamFlag()")
    }
  }

  if (!is.null(reads)) {
    if (!is.character(reads) | length(reads) != 1) {
      stop("reads must be a character vector of length 1")
    }
  } else {
    reads <- "."
  }

  if (!is.null(bad_reads)) {
    if (!is.character(bad_reads) | length(bad_reads) != 1) {
      stop("bad_reads must be a character vector of length 1")
    }
  } else {
    bad_reads <- "."
  }

  filterParam <- .adjustParams(filterParam, n_files)
  fp <- .as.list_FilterParam(filterParam)

  # encode libtype as
  # 0 = genomic-unstranded  all reads on + strand
  # 1 = fr-first-strand     strand based on R1/antisense, R2/sense
  # 2 = fr-second-strand    strand based on R1/sense, R2/antisense
  # 3 = unstranded          strand based on alignment
  lib_values <- c("genomic-unstranded",
    "fr-first-strand",
    "fr-second-strand",
    "unstranded")
  lib_code <- match(fp$library_type, lib_values)
  if (any(is.na(lib_code))) {
    stop("library_type must be one of :", paste(lib_values, collapse = " "))
  } else {
    lib_code <- lib_code - 1
  }

  if (length(lib_code) != n_files) {
    lib_code <- rep(lib_code, n_files)
  }
  event_filters <- unlist(fp[c("trim_5p",
    "trim_3p",
    "splice_dist",
    "indel_dist",
    "homopolymer_len",
    "max_mismatch_type",
    "min_read_qual")])
  run_in_parallel <- FALSE
  temp_bed_file <- FALSE
  if (is(BPPARAM, "SerialParam") || length(chroms_to_process) == 1) {
    if (length(chroms_to_process) > 1 && is.null(bedfile)) {
      temp_bed_file <- TRUE
      bedfile <- tempfile(fileext = ".bed")
      to_process <- contig_info[chroms_to_process]
      bed_gr <- GRanges(paste0(names(to_process), ":", 1, "-", to_process))
      rtracklayer::export(bed_gr, bedfile)
    }

    res <- run_pileup(bampaths = bamfiles,
      fapath = fafile,
      region = region,
      bedfn = ifelse(is.null(bedfile), ".", bedfile),
      min_reads = fp$min_nucleotide_depth,
      event_filters = event_filters,
      min_mapQ = fp$min_mapq,
      max_depth = fp$max_depth,
      min_baseQ = fp$min_base_quality,
      read_bqual_filter = fp$min_read_bqual,
      libtype =  as.integer(lib_code),
      in_memory = in_memory,
      multi_region = use_index,
      outfns = outfiles,
      bam_flags = bam_flags,
      fp$only_keep_variants,
      reads,
      bad_reads,
      idx_ptr)

    if (!in_memory) {
      if (res != 0) {
        stop("Error occured during pileup", call. = FALSE)
      }
    } else {
      res <- lists_to_grs(res, contigs)
    }

    if (temp_bed_file) unlink(bedfile)

  } else {

    run_in_parallel <- TRUE
    res <- bplapply(chroms_to_process, FUN = function(ctig) {
      start_time <- Sys.time()
      tmp_outfiles <- unlist(lapply(seq_along(outfiles), function(x) tempfile()))
      fn_df <- data.frame(contig = ctig,
        bam_fn = bamfiles,
        tmpfn = tmp_outfiles)

      res <- run_pileup(bampaths = bamfiles,
        fapath = fafile,
        region = ctig,
        bedfn = ifelse(is.null(bedfile), ".", bedfile),
        min_reads = fp$min_nucleotide_depth,
        event_filters = event_filters,
        min_mapQ = fp$min_mapq,
        max_depth = fp$max_depth,
        min_baseQ = fp$min_base_quality,
        read_bqual_filter = fp$min_read_bqual,
        libtype =  as.integer(lib_code),
        in_memory = in_memory,
        multi_region = use_index,
        outfns = tmp_outfiles,
        bam_flags = bam_flags,
        fp$only_keep_variants,
        reads,
        bad_reads,
        idx_ptr)

      if (!in_memory) {
        if (res != 0) {
          stop("Error occured during pileup", call. = FALSE)
        }
        res <- fn_df
      } else {
        res <- lists_to_grs(res, contigs)
      }

      if (verbose) {
        time_elapsed <- Sys.time() - start_time
        message("Completed pileup on ", ctig, " in ", time_elapsed)
      }
      res
    },
    BPPARAM = BPPARAM)

    bpstop(BPPARAM)

    if (!in_memory) {
      tmp_fns <- do.call(rbind, res)
      tmp_fns <- split(tmp_fns, tmp_fns$bam_fn)
      stopifnot(length(tmp_fns) == length(outfiles))

      for (i in seq_along(tmp_fns)) {
        fns <- tmp_fns[[i]]$tmpfn
        final_file <- outfiles[i]
        fw <- file.append(final_file, fns)
        if (!all(fw)) {
          stop("error occured writing pileup files")
        }
        unlink(fns)
      }
    } else {
      # res contains an outer list per chromosome
      # and an inner list of GRanges per pileup.
      # transpose to obtain an outer list per pileup
      res <- t_lst(res)
      res <- lapply(res, function(x) {
        unlist(as(x, "GRangesList"))
      })
    }

  }

  if (!in_memory) {
    if (any(file.info(outfiles)$size == 0)) {
      return(empty_plp_record())
    }

    # run_pileup writes to a (temp)file, next the file will be tabix indexed
    tbxfiles <- lapply(outfiles, function(x) {
      tbxfile <- Rsamtools::bgzip(x, overwrite = TRUE)
      idx <- Rsamtools::indexTabix(tbxfile, seq = 1, start = 2, end = 2, zeroBased = FALSE)
      tbxfile
    })

    if (!return_data) {
      unlink(outfiles)
      return(unlist(tbxfiles))
    }

    res <- lapply(tbxfiles, function(x) {
      xx <- read_pileup(x, region = NULL)
      GenomeInfoDb::seqlevels(xx) <- GenomeInfoDb::seqlevels(contigs)
      GenomeInfoDb::seqinfo(xx) <- contigs
      xx
    })

    unlink(outfiles)
  }

  if (n_files == 1) {
    res <- res[[1]]
  }

  res
}

MAX_INT <- 536870912

#' Read pileup, indexed by tabix
#' @param tbx_fn filename
#' @param region region to read from file, samtools style
#' region specifiers are supported.
#'
#' @examples
#' bamfn <- system.file("extdata", "SRR5564269_Aligned.sortedByCoord.out.md.bam", package = "raer")
#' fafn <- system.file("extdata", "human.fasta", package = "raer")
#' plp_fn <- tempfile()
#' plp <- get_pileup(bamfn, fafn, return_data = FALSE, outfile_prefix = plp_fn)
#' read_pileup(plp)
#' unlink(c(plp, plp_fn, paste0(plp, ".tbi")))
#' @importFrom data.table fread
#' @export
read_pileup <- function(tbx_fn, region = NULL) {

  tbx <- Rsamtools::TabixFile(tbx_fn)

  # using Rsamtools read in tabix file
  # note that file is read in as a list of character vectors
  # consider using our own read_tabix function if this is a bottleneck
  if (!is.null(region)) {
    ivl_vals <- get_region(region)
    # note that samtools will return a larger INT than IRANGES can handle
    # if no ranges are supplied in the region
    ivl_end <- min(MAX_INT, ivl_vals$end)
    params <- GenomicRanges::GRanges(ivl_vals$chrom,
      IRanges::IRanges(start = ivl_vals$start + 1,
        end = ivl_end))
    tbx_vals <- Rsamtools::scanTabix(tbx, param = params)[[1]]
  } else {
    tbx_vals <- Rsamtools::scanTabix(tbx)[[1]]
  }

  # quick method to convert vector of character strings into data.frame
  if (length(tbx_vals) == 1) {
    # handle length 1 character vectors, which will not work with fread
    from <- data.frame(t(strsplit(tbx_vals, "\t")[[1]]))
    colnames(from) <- paste0("V", 1:ncol(from))
    from[c(2, 6:12)] <- as.numeric(from[c(2, 6:12)])
  } else {
    from <- data.table::fread(text = tbx_vals,
      stringsAsFactors = FALSE,
      data.table = FALSE,
      showProgress = FALSE,
      sep = "\t")
  }

  count_cols <- c("nRef", "nVar", "nA", "nT", "nC", "nG", "nN")

  colnames(from)[4:ncol(from)] <- c("Ref", "Var", count_cols)

  GenomicRanges::GRanges(seqnames = from$V1,
    ranges = IRanges::IRanges(start = from$V2,
      end = from$V2),
    strand = from$V3,
    from[, 4:ncol(from)])
}



# generate empty pileup record
# idea from @user2462304 https://stackoverflow.com/a/48180979/6276041
empty_plp_record <-  function() {
  col_types <- list(Ref = character(),
    Var = character(),
    nRef = integer(),
    nVar = integer(),
    nA = integer(),
    nT = integer(),
    nC = integer(),
    nG = integer(),
    nN = integer())
  df <- do.call(data.frame, col_types)
  gr <- GRanges(c(seqnames = NULL, ranges = NULL, strand = NULL))
  mcols(gr) <- df
  gr
}


.adjust_arg_length <- function(obj, name, len) {
  if (length(slot(obj, name)) != len) {
    if (length(slot(obj, name)) == 1) {
      slot(obj, name) <- rep(slot(obj, name), len)
    } else {
      stop("%s requires either 1 value, or individual values,",
        "for all input bamfiles", slot)
    }
  }
  slot(obj, name)
}
## Check validity and adjust
.adjustParams <- function(filterParam, nFiles) {
  if (!inherits(filterParam, "FilterParam")) {
    stop("'filterParam' must inherit from 'FilterParam', got '%s'",
      class(filterParam))
  }
  filterParam@min_mapq <- .adjust_arg_length(filterParam,
    "min_mapq",
    nFiles)
  filterParam@only_keep_variants <- .adjust_arg_length(filterParam,
    "only_keep_variants",
    nFiles)
  filterParam@library_type <- .adjust_arg_length(filterParam,
    "library_type",
    nFiles)
  filterParam
}


#' @importFrom methods slot slot<- slotNames
.FilterParam <- setClass("FilterParam",
  representation(
    max_depth = "integer",
    min_base_quality = "integer",
    min_mapq = "integer",
    min_nucleotide_depth = "integer",
    library_type = "character",
    only_keep_variants = "logical",
    ignore_query_Ns = "logical",
    trim_5p = "integer",
    trim_3p = "integer",
    indel_dist = "integer",
    splice_dist = "integer",
    homopolymer_len = "integer",
    max_mismatch_type = "integer", # length 2
    min_read_bqual = "numeric" # length 2
))

setMethod(show, "FilterParam", function(object) {
  cat("class: ", class(object), "\n")
  values <- sapply(slotNames(object), slot, object = object)
  info <- paste(slotNames(object), values, sep = ": ", collapse = "; ")
  cat(strwrap(info, exdent = 2), sep = "\n")
})

.as.list_FilterParam <- function(x, ...) {
  slotnames <- slotNames(x)
  names(slotnames) <- slotnames
  lapply(slotnames, slot, object = x)
}


#' @param min_nucleotide_depth min read depth needed to report site
#' @param min_base_quality min base quality score to consider read for pileup
#' @param max_depth maximum read depth considered at each site
#' @param min_mapq minimum required MAPQ score, can be a vector of values
#' for each bam file
#' @param library_type read orientation, one of fr-first-strand,
#' fr-second-strand, unstranded, and genomic-unstranded. Can supply as a vector to specify for each
#' input bam. Unstranded library type will be reported based on read alignment.
#' genomic-unstranded will report all variants w.r.t the + strand.
#' @param only_keep_variants if TRUE, then only variant sites will be reported
#' (FALSE by default), can be a vector for each input bamfile
#' @param trim_5p Bases to trim from 5' ends of read alignments
#' @param trim_3p Bases to trim from 3' ends of read alignments
#' @param splice_dist Exclude read if site occurs within given
#' distance from splicing event in the read
#' @param indel_dist Exclude read if site occurs within given
#' distance from indel event in the read
#' @param homopolymer_len Exclude site if occurs within homopolymer of given
#' length
#' @param max_mismatch_type Exclude read if it has X different mismatch types
#' (e.g A-to-G, G-to-C, C-to-G, is 3 mismatch types) or Y # of mismatches,
#' must be supplied as a integer vector of length 2. e.g.
#' c(X, Y).
#' @param min_read_bqual Exclude read if more than X percent of the bases have
#' base qualities less than Y. Numeric vector of length 2. e.g. c(0.25, 20)
#' @param ignore_query_Ns ignored for now

#'
#' @rdname get_pileup
#' @export
FilterParam <-
  function(max_depth = 1e4, min_base_quality = 20L,
           min_mapq = 0L, min_nucleotide_depth = 1L,
           library_type = "fr-first-strand",
           only_keep_variants = FALSE,
           trim_5p = 0L, trim_3p = 0L, indel_dist = 0L,
           splice_dist = 0L, homopolymer_len = 0L,
           max_mismatch_type = c(0L, 0L), min_read_bqual = c(0.0, 0.0),
           ignore_query_Ns = FALSE) {

    stopifnot(isSingleNumber(max_depth))
    stopifnot(isSingleNumber(min_base_quality))
    stopifnot(isSingleNumber(min_nucleotide_depth))
    stopifnot(isSingleNumber(trim_5p))
    stopifnot(isSingleNumber(trim_3p))
    stopifnot(isSingleNumber(indel_dist))
    stopifnot(isSingleNumber(splice_dist))
    stopifnot(isSingleNumber(homopolymer_len))

    max_depth <- as.integer(max_depth)
    min_base_quality <- as.integer(min_base_quality)

    min_nucleotide_depth <- as.integer(min_nucleotide_depth)
    trim_5p <- as.integer(trim_5p)
    trim_3p <- as.integer(trim_3p)
    indel_dist <- as.integer(indel_dist)
    splice_dist <- as.integer(splice_dist)
    min_mapq <- as.integer(min_mapq)
    homopolymer_len <- as.integer(homopolymer_len)
    max_mismatch_type <- as.integer(max_mismatch_type)
    min_read_bqual <- as.numeric(min_read_bqual)

    stopifnot(length(max_mismatch_type) == 2 && !any(is.na(max_mismatch_type)))
    stopifnot(length(min_read_bqual) == 2 && !any(is.na(min_read_bqual)))
    stopifnot(isTRUEorFALSE(ignore_query_Ns))

    # variable length depending on n_files
    stopifnot(is.character(library_type))
    stopifnot(is.integer(min_mapq))
    stopifnot(is.logical(only_keep_variants))

    # to implement
    if (ignore_query_Ns) {
      warning("ignore_query_Ns not yet implemented")
      ignore_query_Ns <- FALSE
    }

    ## creation
    .FilterParam(max_depth = max_depth, min_base_quality = min_base_quality,
      min_mapq = min_mapq, min_nucleotide_depth = min_nucleotide_depth,
      library_type = library_type, only_keep_variants = only_keep_variants,
      ignore_query_Ns = ignore_query_Ns,
      trim_5p = trim_5p, trim_3p = trim_3p, indel_dist = indel_dist,
      splice_dist = splice_dist, homopolymer_len = homopolymer_len,
      max_mismatch_type = max_mismatch_type, min_read_bqual = min_read_bqual)

  }

PILEUP_COLS <-  c("seqnames",
                  "pos",
                  "strand",
                  "Ref",
                  "Var",
                  "nRef",
                  "nVar",
                  "nA",
                  "nT",
                  "nC",
                  "nG",
                  "nN")

# convert list of lists to list of grs
lists_to_grs <- function(x, seqinfo = NULL) {
  mc_cols <- setdiff(PILEUP_COLS, c("seqnames", "pos", "strand"))
  lapply(x, function(mc) {
    GRanges(seqnames = mc$seqname,
            ranges = IRanges(start = mc$pos,
                             width = 1L),
            strand = mc$strand,
            mc[mc_cols],
            seqinfo = seqinfo)
  })
}
